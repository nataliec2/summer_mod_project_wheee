---
title: "Satfunc5.0_fid3"
author: "Natalie Chong"
date: "12/6/2020"
output: html_document
---

# 12/06/2020 - Our most recent markdown! This markdown records yet another variation of a fidelity function, fidelity as just our temporary resource pool abundance instead of saturating to it.
```{r}
D <- 0.5 # Dilution Rate (Outflow)
R_0 <- 25 # Inflow Concentration (Nitrogen)
l <- 0.05 # fungal mortality
s <- 0.05 # senescence coefficient
c <- 0.7 # host's C:N Ratio
z <- 0.3 #cost of being a mutualist per unit of uptake rate* 
C_a <- 0.3 #Allocation Carbon
C_c <- 0.2 #Construction Carbon 
v <- 0.1  #Conversion efficiency, Host carbon to more symbionts
a <- 1.872335 # Resource's half-saturation constant.**This is k in equation!**
l_x <- 0.2 # loss back to R pool per unit of nutrient, let resident and mutant to have the same loss
l_y <- 0.2
g <- 0.8 #Tree's per capita growth rate
uset <- seq(0, 1, 1/1000)
uset2 <- seq(0, 1, 1/100)
```

# Fidelity  function.
```{r}
fun4 <- function(u_m,R,H){(u_m*R)/(l_x + g*H)}
```

# Temporary resource pool function.
```{r}
x <- function(u_m, R, H){(u_m*R)/(l_x + g*H)}
```


# Host bifurcation diagram function.
```{r}
host_uptake <- function(u_m, R, H, M){uset2 <- seq(0, 1, 1/100) #decrease last input to make graph smooth
Hset <- NaN*uset2

for(i in 1:length(uset2)){
  u_m <- as.numeric(uset2[i])
tset <- seq(from=0, to= 500, length.out = 100000)
H.simu1 <- NaN*tset; H.simu1[1] <- 1
M.simu1 <- NaN*tset; M.simu1[1] <- 1
R.simu1 <- NaN*tset; R.simu1[1] <- 10

for(k in 2:length(tset)){
    dt <- tset[k] - tset[k-1] 
    H <- H.simu1[k-1] 
    M <- M.simu1[k-1]
    R <- R.simu1[k-1]
  
    
    dR <- (D*(R_0 - R) + s*H/c - u_m*R*M + l_x*M*x(u_m, R,H))*dt
    dH <- (c*g*x(u_m, R, H)*M*H  - (s*H) - ((fun4(u_m,R,H)*C_a) + C_c)*M*H  )*dt #addesd H term in the positive portion of the equation, host can't exist without already being in the system!
    dM <- (v*(1-(u_m*z))*(C_c + (fun4(u_m,R,H)*C_a))*H*M - l*M)*dt
  
    
    H.simu1[k] <- H + dH
    M.simu1[k] <- M + dM
    R.simu1[k] <- R + dR
    
    }
Hset[i] <- H.simu1[length(tset)]

  }
}
```

# When k = 0.5
```{r}
a = 0.5
```


```{r}
mutset5.8 <- matrix(NaN,nrow = 21, ncol = 21, dimnames = list(seq(0, 1, 1/20), seq(0, 1, 1/20))) #name rows to be u_m ; cols to be u_n. made a matrix thingie yay

dt <- 0.01

for(i in 1:nrow(mutset5.8)){ #mutset5.8: records every individual who won. nrow here is analogous to "length" command.
u_m <-  as.numeric(rownames(mutset5.8)[i]) 
   
#**    
tset <- seq(from=0, to= 300, length.out = 10000)
H.simu1 <- NaN*tset; H.simu1[1] <- 1
M.simu1 <- NaN*tset; M.simu1[1] <- 1
R.simu1 <- NaN*tset; R.simu1[1] <- 10

for(k in 2:length(tset)){
    dt <- tset[k] - tset[k-1] 
    H <- H.simu1[k-1] 
    M <- M.simu1[k-1]
    R <- R.simu1[k-1]
    
    dR <- (D*(R_0 - R) + s*H/c - u_m*R*M + l_x*M*x(u_m, R,H))*dt
    dH <- (c*g*x(u_m, R, H)*H*M  - (s*H) - ((fun4(u_m,R,H)*C_a) + C_c)*M*H  )*dt #host can't exist without already being in the system!
    dM <- (v*(1-(u_m*z))*(C_c + (fun4(u_m,R,H)*C_a))*H*M - l*M)*dt
    H.simu1[k] <- H + dH
    M.simu1[k] <- M + dM
    R.simu1[k] <- R + dR
    
} 
# run this intial condition loop in a seperate markdown to make sure that everything has equilibrated.
H0 <- H.simu1[length(tset)]
R0 <- R.simu1[length(tset)]
M_i <- M.simu1[length(tset)]

#Store Resident equilibrium values.
 H <- H0
 R <- R0
 M <- M_i
 dt <- 0.01

# For every value of u_n.
 for(j in 1: ncol(mutset5.8)){
    u_n <- as.numeric(colnames(mutset5.8)[j])
 
  numberofreps <- 0 
  H <- H0
  R <- R0
  N <- .01*M_i
  M <- .99*M_i
  
 
  
    N.N <- (v*(1-(u_n*z))*(C_c + (fun4(u_n,R,H)*C_a))*H - l)*dt
    
    
 mutset5.8[[i,j]] <- N.N
   

    if(i == j){N.N <- 0} #We added this. Maybe considered cheating.
    if(N.N > 0){mutset5.8[[i,j]] <- TRUE} 
    if(N.N <= 0){mutset5.8[[i,j]] <- FALSE}

 }
  }
 

 library('plot.matrix')
  par(mar = c(4,4,4,4))
  plot(mutset5.8, border= NA,  fmt.cell='%.1f', fmt.key ="%.2f", xlab= "Mutant Uptake Rate, u_n", ylab = "Resident Uptake Rate, u_m", col = c('white','black') ) 
    
```

#Host abundance as a function of uptake rate when k = 0.5
```{r}
Hset1 <- host_uptake(u_m, R, H, M)
uset2 <- seq(0, 1, 1/100)
plot(x = uset2, y = Hset1, lwd = 2, xlab = "Uptake Rate, u_m", ylab = "Host Abundance at equilibrium, H*", col = 'darkgreen') 
```


# When k = 0.75
```{r}
a = 0.75
```


```{r}
mutset5.9 <- matrix(NaN,nrow = 21, ncol = 21, dimnames = list(seq(0, 1, 1/20), seq(0, 1, 1/20))) #name rows to be u_m ; cols to be u_n. made a matrix thingie yay

dt <- 0.01

for(i in 1:nrow(mutset5.9)){ #mutset5.9: records every individual who won. nrow here is analogous to "length" command.
u_m <-  as.numeric(rownames(mutset5.9)[i]) 
   
#**    
tset <- seq(from=0, to= 300, length.out = 10000)
H.simu1 <- NaN*tset; H.simu1[1] <- 1
M.simu1 <- NaN*tset; M.simu1[1] <- 1
R.simu1 <- NaN*tset; R.simu1[1] <- 10

for(k in 2:length(tset)){
    dt <- tset[k] - tset[k-1] 
    H <- H.simu1[k-1] 
    M <- M.simu1[k-1]
    R <- R.simu1[k-1]
    
    dR <- (D*(R_0 - R) + s*H/c - u_m*R*M + l_x*M*x(u_m, R,H))*dt
    dH <- (c*g*x(u_m, R, H)*H*M  - (s*H) - ((fun4(u_m,R,H)*C_a) + C_c)*M*H  )*dt #host can't exist without already being in the system!
    dM <- (v*(1-(u_m*z))*(C_c + (fun4(u_m,R,H)*C_a))*H*M - l*M)*dt
    H.simu1[k] <- H + dH
    M.simu1[k] <- M + dM
    R.simu1[k] <- R + dR
    
} 
# run this intial condition loop in a seperate markdown to make sure that everything has equilibrated.
H0 <- H.simu1[length(tset)]
R0 <- R.simu1[length(tset)]
M_i <- M.simu1[length(tset)]

#Store Resident equilibrium values.
 H <- H0
 R <- R0
 M <- M_i
 dt <- 0.01

# For every value of u_n.
 for(j in 1: ncol(mutset5.9)){
    u_n <- as.numeric(colnames(mutset5.9)[j])
 
  numberofreps <- 0 
  H <- H0
  R <- R0
  N <- .01*M_i
  M <- .99*M_i
  
 
  
    N.N <- (v*(1-(u_n*z))*(C_c + (fun4(u_n,R,H)*C_a))*H - l)*dt
    
    
 mutset5.9[[i,j]] <- N.N
   

    if(i == j){N.N <- 0} #We added this. Maybe considered cheating.
    if(N.N > 0){mutset5.9[[i,j]] <- TRUE} 
    if(N.N <= 0){mutset5.9[[i,j]] <- FALSE}

 }
  }
 

 library('plot.matrix')
  par(mar = c(4,4,4,4))
  plot(mutset5.9, border= NA,  fmt.cell='%.1f', fmt.key ="%.2f", xlab= "Mutant Uptake Rate, u_n", ylab = "Resident Uptake Rate, u_m", col = c('white','black') ) 
    
```

#Host abundance as a function of uptake rate when k = 0.75
```{r}
Hset2 <- host_uptake(u_m, R, H, M)

plot(x = uset2, y = Hset2, lwd = 2, xlab = "Uptake Rate, u_m", ylab = "Host Abundance at equilibrium, H*", col = 'darkgreen') 
```


# When k = 1.75
```{r}
a = 1.75
```


```{r}
mutset5.10 <- matrix(NaN,nrow = 21, ncol = 21, dimnames = list(seq(0, 1, 1/20), seq(0, 1, 1/20))) #name rows to be u_m ; cols to be u_n. made a matrix thingie yay

dt <- 0.01

for(i in 1:nrow(mutset5.10)){ #mutset5.10: records every individual who won. nrow here is analogous to "length" command.
u_m <-  as.numeric(rownames(mutset5.10)[i]) 
   
#**    
tset <- seq(from=0, to= 300, length.out = 10000)
H.simu1 <- NaN*tset; H.simu1[1] <- 1
M.simu1 <- NaN*tset; M.simu1[1] <- 1
R.simu1 <- NaN*tset; R.simu1[1] <- 10

for(k in 2:length(tset)){
    dt <- tset[k] - tset[k-1] 
    H <- H.simu1[k-1] 
    M <- M.simu1[k-1]
    R <- R.simu1[k-1]
    
    dR <- (D*(R_0 - R) + s*H/c - u_m*R*M + l_x*M*x(u_m, R,H))*dt
    dH <- (c*g*x(u_m, R, H)*H*M  - (s*H) - ((fun4(u_m,R,H)*C_a) + C_c)*M*H  )*dt #host can't exist without already being in the system!
    dM <- (v*(1-(u_m*z))*(C_c + (fun4(u_m,R,H)*C_a))*H*M - l*M)*dt
    H.simu1[k] <- H + dH
    M.simu1[k] <- M + dM
    R.simu1[k] <- R + dR
    
} 
# run this intial condition loop in a seperate markdown to make sure that everything has equilibrated.
H0 <- H.simu1[length(tset)]
R0 <- R.simu1[length(tset)]
M_i <- M.simu1[length(tset)]

#Store Resident equilibrium values.
 H <- H0
 R <- R0
 M <- M_i
 dt <- 0.01

# For every value of u_n.
 for(j in 1: ncol(mutset5.10)){
    u_n <- as.numeric(colnames(mutset5.10)[j])
 
  numberofreps <- 0 
  H <- H0
  R <- R0
  N <- .01*M_i
  M <- .99*M_i
  
 
  
    N.N <- (v*(1-(u_n*z))*(C_c + (fun4(u_n,R,H)*C_a))*H - l)*dt
    
    
 mutset5.10[[i,j]] <- N.N
   

    if(i == j){N.N <- 0} #We added this. Maybe considered cheating.
    if(N.N > 0){mutset5.10[[i,j]] <- TRUE} 
    if(N.N <= 0){mutset5.10[[i,j]] <- FALSE}

 }
  }
 

 library('plot.matrix')
  par(mar = c(4,4,4,4))
  plot(mutset5.10, border= NA,  fmt.cell='%.1f', fmt.key ="%.2f", xlab= "Mutant Uptake Rate, u_n", ylab = "Resident Uptake Rate, u_m", col = c('white','black') ) 
    
```

#Host abundance as a function of uptake rate when k = 1.75
```{r}
Hset3 <- host_uptake(u_m, R, H, M)

plot(x = uset2, y = Hset3, lwd = 2, xlab = "Uptake Rate, u_m", ylab = "Host Abundance at equilibrium, H*", col = 'darkgreen') 
```


# When k = 1.87
```{r}
a = 1.87
```

```{r}
mutset5.11 <- matrix(NaN,nrow = 21, ncol = 21, dimnames = list(seq(0, 1, 1/20), seq(0, 1, 1/20))) #name rows to be u_m ; cols to be u_n. made a matrix thingie yay

dt <- 0.01

for(i in 1:nrow(mutset5.11)){ #mutset5.11: records every individual who won. nrow here is analogous to "length" command.
u_m <-  as.numeric(rownames(mutset5.11)[i]) 
   
#**    
tset <- seq(from=0, to= 300, length.out = 10000)
H.simu1 <- NaN*tset; H.simu1[1] <- 1
M.simu1 <- NaN*tset; M.simu1[1] <- 1
R.simu1 <- NaN*tset; R.simu1[1] <- 10

for(k in 2:length(tset)){
    dt <- tset[k] - tset[k-1] 
    H <- H.simu1[k-1] 
    M <- M.simu1[k-1]
    R <- R.simu1[k-1]
    
    dR <- (D*(R_0 - R) + s*H/c - u_m*R*M + l_x*M*x(u_m, R,H))*dt
    dH <- (c*g*x(u_m, R, H)*H*M  - (s*H) - ((fun4(u_m,R,H)*C_a) + C_c)*M*H  )*dt #host can't exist without already being in the system!
    dM <- (v*(1-(u_m*z))*(C_c + (fun4(u_m,R,H)*C_a))*H*M - l*M)*dt
    H.simu1[k] <- H + dH
    M.simu1[k] <- M + dM
    R.simu1[k] <- R + dR
    
} 
# run this intial condition loop in a seperate markdown to make sure that everything has equilibrated.
H0 <- H.simu1[length(tset)]
R0 <- R.simu1[length(tset)]
M_i <- M.simu1[length(tset)]

#Store Resident equilibrium values.
 H <- H0
 R <- R0
 M <- M_i
 dt <- 0.01

# For every value of u_n.
 for(j in 1: ncol(mutset5.11)){
    u_n <- as.numeric(colnames(mutset5.11)[j])
 
  numberofreps <- 0 
  H <- H0
  R <- R0
  N <- .01*M_i
  M <- .99*M_i
  
 
  
    N.N <- (v*(1-(u_n*z))*(C_c + (fun4(u_n,R,H)*C_a))*H - l)*dt
    
    
 mutset5.11[[i,j]] <- N.N
   

    if(i == j){N.N <- 0} #We added this. Maybe considered cheating.
    if(N.N > 0){mutset5.11[[i,j]] <- TRUE} 
    if(N.N <= 0){mutset5.11[[i,j]] <- FALSE}

 }
  }
 

 library('plot.matrix')
  par(mar = c(4,4,4,4))
  plot(mutset5.11, border= NA,  fmt.cell='%.1f', fmt.key ="%.2f", xlab= "Mutant Uptake Rate, u_n", ylab = "Resident Uptake Rate, u_m", col = c('white','black') ) 
    
```

#Host abundance as a function of uptake rate when k = 1.87
```{r}
Hset3 <- host_uptake(u_m, R, H, M)

plot(x = uset2, y = Hset3, lwd = 2, xlab = "Uptake Rate, u_m", ylab = "Host Abundance at equilibrium, H*", col = 'darkgreen') 
```


# When k = 2
```{r}
a = 2
```


```{r}
mutset5.12 <- matrix(NaN,nrow = 21, ncol = 21, dimnames = list(seq(0, 1, 1/20), seq(0, 1, 1/20))) #name rows to be u_m ; cols to be u_n. made a matrix thingie yay

dt <- 0.01

for(i in 1:nrow(mutset5.12)){ #mutset5.12: records every individual who won. nrow here is analogous to "length" command.
u_m <-  as.numeric(rownames(mutset5.12)[i]) 
   
#**    
tset <- seq(from=0, to= 300, length.out = 10000)
H.simu1 <- NaN*tset; H.simu1[1] <- 1
M.simu1 <- NaN*tset; M.simu1[1] <- 1
R.simu1 <- NaN*tset; R.simu1[1] <- 10

for(k in 2:length(tset)){
    dt <- tset[k] - tset[k-1] 
    H <- H.simu1[k-1] 
    M <- M.simu1[k-1]
    R <- R.simu1[k-1]
    
    dR <- (D*(R_0 - R) + s*H/c - u_m*R*M + l_x*M*x(u_m, R,H))*dt
    dH <- (c*g*x(u_m, R, H)*H*M  - (s*H) - ((fun4(u_m,R,H)*C_a) + C_c)*M*H  )*dt #host can't exist without already being in the system!
    dM <- (v*(1-(u_m*z))*(C_c + (fun4(u_m,R,H)*C_a))*H*M - l*M)*dt
    H.simu1[k] <- H + dH
    M.simu1[k] <- M + dM
    R.simu1[k] <- R + dR
    
} 
# run this intial condition loop in a seperate markdown to make sure that everything has equilibrated.
H0 <- H.simu1[length(tset)]
R0 <- R.simu1[length(tset)]
M_i <- M.simu1[length(tset)]

#Store Resident equilibrium values.
 H <- H0
 R <- R0
 M <- M_i
 dt <- 0.01

# For every value of u_n.
 for(j in 1: ncol(mutset5.12)){
    u_n <- as.numeric(colnames(mutset5.12)[j])
 
  numberofreps <- 0 
  H <- H0
  R <- R0
  N <- .01*M_i
  M <- .99*M_i
  
 
  
    N.N <- (v*(1-(u_n*z))*(C_c + (fun4(u_n,R,H)*C_a))*H - l)*dt
    
    
 mutset5.12[[i,j]] <- N.N
   

    if(i == j){N.N <- 0} #We added this. Maybe considered cheating.
    if(N.N > 0){mutset5.12[[i,j]] <- TRUE} 
    if(N.N <= 0){mutset5.12[[i,j]] <- FALSE}

 }
  }
 

 library('plot.matrix')
  par(mar = c(4,4,4,4))
  plot(mutset5.12, border= NA,  fmt.cell='%.1f', fmt.key ="%.2f", xlab= "Mutant Uptake Rate, u_n", ylab = "Resident Uptake Rate, u_m", col = c('white','black') ) 
    
```

#Host abundance as a function of uptake rate when k = 2
```{r}
Hset4 <- host_uptake(u_m, R, H, M)

plot(x = uset2, y = Hset4, lwd = 2, xlab = "Uptake Rate, u_m", ylab = "Host Abundance at equilibrium, H*", col = 'darkgreen') 
```


# When k = 2.5
```{r}
a = 2.5
```


```{r}
mutset5.13 <- matrix(NaN,nrow = 21, ncol = 21, dimnames = list(seq(0, 1, 1/20), seq(0, 1, 1/20))) #name rows to be u_m ; cols to be u_n. made a matrix thingie yay

dt <- 0.01

for(i in 1:nrow(mutset5.13)){ #mutset5.13: records every individual who won. nrow here is analogous to "length" command.
u_m <-  as.numeric(rownames(mutset5.13)[i]) 
   
#**    
tset <- seq(from=0, to= 300, length.out = 10000)
H.simu1 <- NaN*tset; H.simu1[1] <- 1
M.simu1 <- NaN*tset; M.simu1[1] <- 1
R.simu1 <- NaN*tset; R.simu1[1] <- 10

for(k in 2:length(tset)){
    dt <- tset[k] - tset[k-1] 
    H <- H.simu1[k-1] 
    M <- M.simu1[k-1]
    R <- R.simu1[k-1]
    
    dR <- (D*(R_0 - R) + s*H/c - u_m*R*M + l_x*M*x(u_m, R,H))*dt
    dH <- (c*g*x(u_m, R, H)*H*M  - (s*H) - ((fun4(u_m,R,H)*C_a) + C_c)*M*H  )*dt #host can't exist without already being in the system!
    dM <- (v*(1-(u_m*z))*(C_c + (fun4(u_m,R,H)*C_a))*H*M - l*M)*dt
    H.simu1[k] <- H + dH
    M.simu1[k] <- M + dM
    R.simu1[k] <- R + dR
    
} 
# run this intial condition loop in a seperate markdown to make sure that everything has equilibrated.
H0 <- H.simu1[length(tset)]
R0 <- R.simu1[length(tset)]
M_i <- M.simu1[length(tset)]

#Store Resident equilibrium values.
 H <- H0
 R <- R0
 M <- M_i
 dt <- 0.01

# For every value of u_n.
 for(j in 1: ncol(mutset5.13)){
    u_n <- as.numeric(colnames(mutset5.13)[j])
 
  numberofreps <- 0 
  H <- H0
  R <- R0
  N <- .01*M_i
  M <- .99*M_i
  
 
  
    N.N <- (v*(1-(u_n*z))*(C_c + (fun4(u_n,R,H)*C_a))*H - l)*dt
    
    
 mutset5.13[[i,j]] <- N.N
   

    if(i == j){N.N <- 0} #We added this. Maybe considered cheating.
    if(N.N > 0){mutset5.13[[i,j]] <- TRUE} 
    if(N.N <= 0){mutset5.13[[i,j]] <- FALSE}

 }
  }
 

 library('plot.matrix')
  par(mar = c(4,4,4,4))
  plot(mutset5.13, border= NA,  fmt.cell='%.1f', fmt.key ="%.2f", xlab= "Mutant Uptake Rate, u_n", ylab = "Resident Uptake Rate, u_m", col = c('white','black') ) 
    
```

#Host abundance as a function of uptake rate when k = 2.5
```{r}
Hset5 <- host_uptake(u_m, R, H, M)

plot(x = uset2, y = Hset5, lwd = 2, xlab = "Uptake Rate, u_m", ylab = "Host Abundance at equilibrium, H*", col = 'darkgreen') 
```


# When k = 3
```{r}
a = 3
```


```{r}
mutset5.14 <- matrix(NaN,nrow = 21, ncol = 21, dimnames = list(seq(0, 1, 1/20), seq(0, 1, 1/20))) #name rows to be u_m ; cols to be u_n. made a matrix thingie yay

dt <- 0.01

for(i in 1:nrow(mutset5.14)){ #mutset5.14: records every individual who won. nrow here is analogous to "length" command.
u_m <-  as.numeric(rownames(mutset5.14)[i]) 
   
#**    
tset <- seq(from=0, to= 300, length.out = 10000)
H.simu1 <- NaN*tset; H.simu1[1] <- 1
M.simu1 <- NaN*tset; M.simu1[1] <- 1
R.simu1 <- NaN*tset; R.simu1[1] <- 10

for(k in 2:length(tset)){
    dt <- tset[k] - tset[k-1] 
    H <- H.simu1[k-1] 
    M <- M.simu1[k-1]
    R <- R.simu1[k-1]
    
    dR <- (D*(R_0 - R) + s*H/c - u_m*R*M + l_x*M*x(u_m, R,H))*dt
    dH <- (c*g*x(u_m, R, H)*H*M  - (s*H) - ((fun4(u_m,R,H)*C_a) + C_c)*M*H  )*dt #host can't exist without already being in the system!
    dM <- (v*(1-(u_m*z))*(C_c + (fun4(u_m,R,H)*C_a))*H*M - l*M)*dt
    H.simu1[k] <- H + dH
    M.simu1[k] <- M + dM
    R.simu1[k] <- R + dR
    
} 
# run this intial condition loop in a seperate markdown to make sure that everything has equilibrated.
H0 <- H.simu1[length(tset)]
R0 <- R.simu1[length(tset)]
M_i <- M.simu1[length(tset)]

#Store Resident equilibrium values.
 H <- H0
 R <- R0
 M <- M_i
 dt <- 0.01

# For every value of u_n.
 for(j in 1: ncol(mutset5.14)){
    u_n <- as.numeric(colnames(mutset5.14)[j])
 
  numberofreps <- 0 
  H <- H0
  R <- R0
  N <- .01*M_i
  M <- .99*M_i
  
 
  
    N.N <- (v*(1-(u_n*z))*(C_c + (fun4(u_n,R,H)*C_a))*H - l)*dt
    
    
 mutset5.14[[i,j]] <- N.N
   

    if(i == j){N.N <- 0} #We added this. Maybe considered cheating.
    if(N.N > 0){mutset5.14[[i,j]] <- TRUE} 
    if(N.N <= 0){mutset5.14[[i,j]] <- FALSE}

 }
  }
 

 library('plot.matrix')
  par(mar = c(4,4,4,4))
  plot(mutset5.14, border= NA,  fmt.cell='%.1f', fmt.key ="%.2f", xlab= "Mutant Uptake Rate, u_n", ylab = "Resident Uptake Rate, u_m", col = c('white','black') ) 
    
```

#Host abundance as a function of uptake rate when k = 3
```{r}
Hset5 <- host_uptake(u_m, R, H, M)

plot(x = uset2, y = Hset5, lwd = 2, xlab = "Uptake Rate, u_m", ylab = "Host Abundance at equilibrium, H*", col = 'darkgreen') 
```


# When k = 4
```{r}
a = 4
```


```{r}
mutset5.15 <- matrix(NaN,nrow = 21, ncol = 21, dimnames = list(seq(0, 1, 1/20), seq(0, 1, 1/20))) #name rows to be u_m ; cols to be u_n. made a matrix thingie yay

dt <- 0.01

for(i in 1:nrow(mutset5.15)){ #mutset5.15: records every individual who won. nrow here is analogous to "length" command.
u_m <-  as.numeric(rownames(mutset5.15)[i]) 
   
#**    
tset <- seq(from=0, to= 300, length.out = 10000)
H.simu1 <- NaN*tset; H.simu1[1] <- 1
M.simu1 <- NaN*tset; M.simu1[1] <- 1
R.simu1 <- NaN*tset; R.simu1[1] <- 10

for(k in 2:length(tset)){
    dt <- tset[k] - tset[k-1] 
    H <- H.simu1[k-1] 
    M <- M.simu1[k-1]
    R <- R.simu1[k-1]
    
    dR <- (D*(R_0 - R) + s*H/c - u_m*R*M + l_x*M*x(u_m, R,H))*dt
    dH <- (c*g*x(u_m, R, H)*H*M  - (s*H) - ((fun4(u_m,R,H)*C_a) + C_c)*M*H  )*dt #host can't exist without already being in the system!
    dM <- (v*(1-(u_m*z))*(C_c + (fun4(u_m,R,H)*C_a))*H*M - l*M)*dt
    H.simu1[k] <- H + dH
    M.simu1[k] <- M + dM
    R.simu1[k] <- R + dR
    
} 
# run this intial condition loop in a seperate markdown to make sure that everything has equilibrated.
H0 <- H.simu1[length(tset)]
R0 <- R.simu1[length(tset)]
M_i <- M.simu1[length(tset)]

#Store Resident equilibrium values.
 H <- H0
 R <- R0
 M <- M_i
 dt <- 0.01

# For every value of u_n.
 for(j in 1: ncol(mutset5.15)){
    u_n <- as.numeric(colnames(mutset5.15)[j])
 
  numberofreps <- 0 
  H <- H0
  R <- R0
  N <- .01*M_i
  M <- .99*M_i
  
 
  
    N.N <- (v*(1-(u_n*z))*(C_c + (fun4(u_n,R,H)*C_a))*H - l)*dt
    
    
 mutset5.15[[i,j]] <- N.N
   

    if(i == j){N.N <- 0} #We added this. Maybe considered cheating.
    if(N.N > 0){mutset5.15[[i,j]] <- TRUE} 
    if(N.N <= 0){mutset5.15[[i,j]] <- FALSE}

 }
  }
 

 library('plot.matrix')
  par(mar = c(4,4,4,4))
  plot(mutset5.15, border= NA,  fmt.cell='%.1f', fmt.key ="%.2f", xlab= "Mutant Uptake Rate, u_n", ylab = "Resident Uptake Rate, u_m", col = c('white','black') ) 
    
```

#Host abundance as a function of uptake rate when u_m = 3
```{r}
Hset6 <- host_uptake(u_m, R, H, M)

plot(x = uset2, y = Hset6, lwd = 2, xlab = "Uptake Rate, u_m", ylab = "Host Abundance at equilibrium, H*", col = 'darkgreen') 
```


# When k = 4
```{r}
a = 4
```


```{r}
mutset5.16 <- matrix(NaN,nrow = 21, ncol = 21, dimnames = list(seq(0, 1, 1/20), seq(0, 1, 1/20))) #name rows to be u_m ; cols to be u_n. made a matrix thingie yay

dt <- 0.01

for(i in 1:nrow(mutset5.16)){ #mutset5.16: records every individual who won. nrow here is analogous to "length" command.
u_m <-  as.numeric(rownames(mutset5.16)[i]) 
   
#**    
tset <- seq(from=0, to= 300, length.out = 10000)
H.simu1 <- NaN*tset; H.simu1[1] <- 1
M.simu1 <- NaN*tset; M.simu1[1] <- 1
R.simu1 <- NaN*tset; R.simu1[1] <- 10

for(k in 2:length(tset)){
    dt <- tset[k] - tset[k-1] 
    H <- H.simu1[k-1] 
    M <- M.simu1[k-1]
    R <- R.simu1[k-1]
    
    dR <- (D*(R_0 - R) + s*H/c - u_m*R*M + l_x*M*x(u_m, R,H))*dt
    dH <- (c*g*x(u_m, R, H)*H*M  - (s*H) - ((fun4(u_m,R,H)*C_a) + C_c)*M*H  )*dt #host can't exist without already being in the system!
    dM <- (v*(1-(u_m*z))*(C_c + (fun4(u_m,R,H)*C_a))*H*M - l*M)*dt
    H.simu1[k] <- H + dH
    M.simu1[k] <- M + dM
    R.simu1[k] <- R + dR
    
} 
# run this intial condition loop in a seperate markdown to make sure that everything has equilibrated.
H0 <- H.simu1[length(tset)]
R0 <- R.simu1[length(tset)]
M_i <- M.simu1[length(tset)]

#Store Resident equilibrium values.
 H <- H0
 R <- R0
 M <- M_i
 dt <- 0.01

# For every value of u_n.
 for(j in 1: ncol(mutset5.16)){
    u_n <- as.numeric(colnames(mutset5.16)[j])
 
  numberofreps <- 0 
  H <- H0
  R <- R0
  N <- .01*M_i
  M <- .99*M_i
  
 
  
    N.N <- (v*(1-(u_n*z))*(C_c + (fun4(u_n,R,H)*C_a))*H - l)*dt
    
    
 mutset5.16[[i,j]] <- N.N
   

    if(i == j){N.N <- 0} #We added this. Maybe considered cheating.
    if(N.N > 0){mutset5.16[[i,j]] <- TRUE} 
    if(N.N <= 0){mutset5.16[[i,j]] <- FALSE}

 }
  }
 

 library('plot.matrix')
  par(mar = c(4,4,4,4))
  plot(mutset5.16, border= NA,  fmt.cell='%.1f', fmt.key ="%.2f", xlab= "Mutant Uptake Rate, u_n", ylab = "Resident Uptake Rate, u_m", col = c('white','black') ) 
    
```

#Host abundance as a function of uptake rate when k = 4
```{r}
Hset7 <- host_uptake(u_m, R, H, M)

plot(x = uset2, y = Hset7, lwd = 2, xlab = "Uptake Rate, u_m", ylab = "Host Abundance at equilibrium, H*", col = 'darkgreen') 
```


# When k = 4.5
```{r}
a = 4.5
```


```{r}
mutset5.17 <- matrix(NaN,nrow = 21, ncol = 21, dimnames = list(seq(0, 1, 1/20), seq(0, 1, 1/20))) #name rows to be u_m ; cols to be u_n. made a matrix thingie yay

dt <- 0.01

for(i in 1:nrow(mutset5.17)){ #mutset5.17: records every individual who won. nrow here is analogous to "length" command.
u_m <-  as.numeric(rownames(mutset5.17)[i]) 
   
#**    
tset <- seq(from=0, to= 300, length.out = 10000)
H.simu1 <- NaN*tset; H.simu1[1] <- 1
M.simu1 <- NaN*tset; M.simu1[1] <- 1
R.simu1 <- NaN*tset; R.simu1[1] <- 10

for(k in 2:length(tset)){
    dt <- tset[k] - tset[k-1] 
    H <- H.simu1[k-1] 
    M <- M.simu1[k-1]
    R <- R.simu1[k-1]
    
    dR <- (D*(R_0 - R) + s*H/c - u_m*R*M + l_x*M*x(u_m, R,H))*dt
    dH <- (c*g*x(u_m, R, H)*H*M  - (s*H) - ((fun4(u_m,R,H)*C_a) + C_c)*M*H  )*dt #host can't exist without already being in the system!
    dM <- (v*(1-(u_m*z))*(C_c + (fun4(u_m,R,H)*C_a))*H*M - l*M)*dt
    H.simu1[k] <- H + dH
    M.simu1[k] <- M + dM
    R.simu1[k] <- R + dR
    
} 
# run this intial condition loop in a seperate markdown to make sure that everything has equilibrated.
H0 <- H.simu1[length(tset)]
R0 <- R.simu1[length(tset)]
M_i <- M.simu1[length(tset)]

#Store Resident equilibrium values.
 H <- H0
 R <- R0
 M <- M_i
 dt <- 0.01

# For every value of u_n.
 for(j in 1: ncol(mutset5.17)){
    u_n <- as.numeric(colnames(mutset5.17)[j])
 
  numberofreps <- 0 
  H <- H0
  R <- R0
  N <- .01*M_i
  M <- .99*M_i
  
 
  
    N.N <- (v*(1-(u_n*z))*(C_c + (fun4(u_n,R,H)*C_a))*H - l)*dt
    
    
 mutset5.17[[i,j]] <- N.N
   

    if(i == j){N.N <- 0} #We added this. Maybe considered cheating.
    if(N.N > 0){mutset5.17[[i,j]] <- TRUE} 
    if(N.N <= 0){mutset5.17[[i,j]] <- FALSE}

 }
  }
 

 library('plot.matrix')
  par(mar = c(4,4,4,4))
  plot(mutset5.17, border= NA,  fmt.cell='%.1f', fmt.key ="%.2f", xlab= "Mutant Uptake Rate, u_n", ylab = "Resident Uptake Rate, u_m", col = c('white','black') ) 
    
```

#Host abundance as a function of uptake rate when k = 4.5
```{r}
Hset8 <- host_uptake(u_m, R, H, M)

plot(x = uset2, y = Hset8, lwd = 2, xlab = "Uptake Rate, u_m", ylab = "Host Abundance at equilibrium, H*", col = 'darkgreen') 
```


# When k = 5
```{r}
a = 5
```


```{r}
mutset5.18 <- matrix(NaN,nrow = 21, ncol = 21, dimnames = list(seq(0, 1, 1/20), seq(0, 1, 1/20))) #name rows to be u_m ; cols to be u_n. made a matrix thingie yay

dt <- 0.01

for(i in 1:nrow(mutset5.18)){ #mutset5.18: records every individual who won. nrow here is analogous to "length" command.
u_m <-  as.numeric(rownames(mutset5.18)[i]) 
   
#**    
tset <- seq(from=0, to= 300, length.out = 10000)
H.simu1 <- NaN*tset; H.simu1[1] <- 1
M.simu1 <- NaN*tset; M.simu1[1] <- 1
R.simu1 <- NaN*tset; R.simu1[1] <- 10

for(k in 2:length(tset)){
    dt <- tset[k] - tset[k-1] 
    H <- H.simu1[k-1] 
    M <- M.simu1[k-1]
    R <- R.simu1[k-1]
    
    dR <- (D*(R_0 - R) + s*H/c - u_m*R*M + l_x*M*x(u_m, R,H))*dt
    dH <- (c*g*x(u_m, R, H)*H*M  - (s*H) - ((fun4(u_m,R,H)*C_a) + C_c)*M*H  )*dt #host can't exist without already being in the system!
    dM <- (v*(1-(u_m*z))*(C_c + (fun4(u_m,R,H)*C_a))*H*M - l*M)*dt
    H.simu1[k] <- H + dH
    M.simu1[k] <- M + dM
    R.simu1[k] <- R + dR
    
} 
# run this intial condition loop in a seperate markdown to make sure that everything has equilibrated.
H0 <- H.simu1[length(tset)]
R0 <- R.simu1[length(tset)]
M_i <- M.simu1[length(tset)]

#Store Resident equilibrium values.
 H <- H0
 R <- R0
 M <- M_i
 dt <- 0.01

# For every value of u_n.
 for(j in 1: ncol(mutset5.18)){
    u_n <- as.numeric(colnames(mutset5.18)[j])
 
  numberofreps <- 0 
  H <- H0
  R <- R0
  N <- .01*M_i
  M <- .99*M_i
  
 
  
    N.N <- (v*(1-(u_n*z))*(C_c + (fun4(u_n,R,H)*C_a))*H - l)*dt
    
    
 mutset5.18[[i,j]] <- N.N
   

    if(i == j){N.N <- 0} #We added this. Maybe considered cheating.
    if(N.N > 0){mutset5.18[[i,j]] <- TRUE} 
    if(N.N <= 0){mutset5.18[[i,j]] <- FALSE}

 }
  }
 

 library('plot.matrix')
  par(mar = c(4,4,4,4))
  plot(mutset5.18, border= NA,  fmt.cell='%.1f', fmt.key ="%.2f", xlab= "Mutant Uptake Rate, u_n", ylab = "Resident Uptake Rate, u_m", col = c('white','black') ) 
    
```

#Host abundance as a function of uptake rate when k = 5
```{r}
Hset9 <- host_uptake(u_m, R, H, M)

plot(x = uset2, y = Hset9, lwd = 2, xlab = "Uptake Rate, u_m", ylab = "Host Abundance at equilibrium, H*", col = 'darkgreen') 
```


# When k = 6
```{r}
a = 6
```


```{r}
mutset5.19 <- matrix(NaN,nrow = 21, ncol = 21, dimnames = list(seq(0, 1, 1/20), seq(0, 1, 1/20))) #name rows to be u_m ; cols to be u_n. made a matrix thingie yay

dt <- 0.01

for(i in 1:nrow(mutset5.19)){ #mutset5.19: records every individual who won. nrow here is analogous to "length" command.
u_m <-  as.numeric(rownames(mutset5.19)[i]) 
   
#**    
tset <- seq(from=0, to= 300, length.out = 10000)
H.simu1 <- NaN*tset; H.simu1[1] <- 1
M.simu1 <- NaN*tset; M.simu1[1] <- 1
R.simu1 <- NaN*tset; R.simu1[1] <- 10

for(k in 2:length(tset)){
    dt <- tset[k] - tset[k-1] 
    H <- H.simu1[k-1] 
    M <- M.simu1[k-1]
    R <- R.simu1[k-1]
    
    dR <- (D*(R_0 - R) + s*H/c - u_m*R*M + l_x*M*x(u_m, R,H))*dt
    dH <- (c*g*x(u_m, R, H)*H*M  - (s*H) - ((fun4(u_m,R,H)*C_a) + C_c)*M*H  )*dt #host can't exist without already being in the system!
    dM <- (v*(1-(u_m*z))*(C_c + (fun4(u_m,R,H)*C_a))*H*M - l*M)*dt
    H.simu1[k] <- H + dH
    M.simu1[k] <- M + dM
    R.simu1[k] <- R + dR
    
} 
# run this intial condition loop in a seperate markdown to make sure that everything has equilibrated.
H0 <- H.simu1[length(tset)]
R0 <- R.simu1[length(tset)]
M_i <- M.simu1[length(tset)]

#Store Resident equilibrium values.
 H <- H0
 R <- R0
 M <- M_i
 dt <- 0.01

# For every value of u_n.
 for(j in 1: ncol(mutset5.19)){
    u_n <- as.numeric(colnames(mutset5.19)[j])
 
  numberofreps <- 0 
  H <- H0
  R <- R0
  N <- .01*M_i
  M <- .99*M_i
  
 
  
    N.N <- (v*(1-(u_n*z))*(C_c + (fun4(u_n,R,H)*C_a))*H - l)*dt
    
    
 mutset5.19[[i,j]] <- N.N
   

    if(i == j){N.N <- 0} #We added this. Maybe considered cheating.
    if(N.N > 0){mutset5.19[[i,j]] <- TRUE} 
    if(N.N <= 0){mutset5.19[[i,j]] <- FALSE}

 }
  }
 

 library('plot.matrix')
  par(mar = c(4,4,4,4))
  plot(mutset5.19, border= NA,  fmt.cell='%.1f', fmt.key ="%.2f", xlab= "Mutant Uptake Rate, u_n", ylab = "Resident Uptake Rate, u_m", col = c('white','black') ) 
    
```

#Host abundance as a function of uptake rate when k = 6
```{r}
Hset10 <- host_uptake(u_m, R, H, M)

plot(x = uset2, y = Hset10, lwd = 2, xlab = "Uptake Rate, u_m", ylab = "Host Abundance at equilibrium, H*", col = 'darkgreen') 
```
